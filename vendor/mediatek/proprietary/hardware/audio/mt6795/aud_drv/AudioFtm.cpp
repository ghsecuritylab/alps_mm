/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein is
 * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
 * the prior written permission of MediaTek inc. and/or its licensors, any
 * reproduction, modification, use or disclosure of MediaTek Software, and
 * information contained herein, in whole or in part, shall be strictly
 * prohibited.
 *
 * MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
 * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
 * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
 * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
 * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
 * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
 * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
 * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
 * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
 * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
 * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
 * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
 * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
 * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
 * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek
 * Software") have been modified by MediaTek Inc. All revisions are subject to
 * any receiver's applicable license agreements with MediaTek Inc.
 */

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*******************************************************************************
 *
 * Filename:
 * ---------
 *   AudioFtm.cpp
 *
 * Project:
 * --------
 *   Android Audio Driver
 *
 * Description:
 * ------------
 *   Factory mode Control
 *
 * Author:
 * -------
 *   Chipeng Chang (mtk02308)
 *
 *------------------------------------------------------------------------------
 * $Revision: #5 $
 * $Modtime:$
 * $Log:$
 *
 * 04 10 2012 weiguo.li
 * [ALPS00266592] [Need Patch] [Volunteer Patch] ICS_MP patchback to ALPS.ICS of Audio
 * .
 *
 * 01 11 2012 donglei.ji
 * [ALPS00106007] [Need Patch] [Volunteer Patch]DMNR acoustic loopback feature
 * .
 *
 *
 *******************************************************************************/

/*****************************************************************************
*                     C O M P I L E R   F L A G S
******************************************************************************
*/


/*****************************************************************************
*                E X T E R N A L   R E F E R E N C E S
******************************************************************************
*/

#include <string.h>
#include <stdint.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sched.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <utils/String8.h>
#include <utils/Log.h>

#include "AudioFtm.h"

#include "AudioDef.h"
#include "AudioType.h"

#include "AudioLock.h"

#include "AudioALSAStreamOut.h"

#include "LoopbackManager.h"

#include "AudioALSAHardwareResourceManager.h"

#include "AudioALSAStreamManager.h"

#include "LoopbackManager.h"
#if defined(MTK_SPEAKER_MONITOR_SUPPORT)
#include <AudioALSASpeakerMonitor.h>
#include <AudioCustParam.h>
#endif

#include <CFG_AUDIO_File.h>
#include "audio_custom_exp.h"


#include <tinyalsa/asoundlib.h> // TODO(Harvey): remove later
#include "AudioALSADriverUtility.h"

#define LOG_TAG "AudioFtm"

/*****************************************************************************
*                          C O N S T A N T S
******************************************************************************
*/

static unsigned char stone1k_48kHz[192] =
{
    0x00, 0x00, 0xFF, 0xFF, 0xB5, 0x10, 0xB5, 0x10, 0x21, 0x21, 0x21, 0x21,
    0xFC, 0x30, 0xFC, 0x30, 0x00, 0x40, 0x00, 0x40, 0xEB, 0x4D, 0xEB, 0x4D,
    0x81, 0x5A, 0x82, 0x5A, 0x8C, 0x65, 0x8C, 0x65, 0xD9, 0x6E, 0xD9, 0x6E,
    0x40, 0x76, 0x41, 0x76, 0xA3, 0x7B, 0xA2, 0x7B, 0xE7, 0x7E, 0xE6, 0x7E,
    0xFF, 0x7F, 0xFF, 0x7F, 0xE6, 0x7E, 0xE7, 0x7E, 0xA2, 0x7B, 0xA2, 0x7B,
    0x41, 0x76, 0x41, 0x76, 0xD9, 0x6E, 0xD8, 0x6E, 0x8D, 0x65, 0x8C, 0x65,
    0x82, 0x5A, 0x81, 0x5A, 0xEB, 0x4D, 0xEB, 0x4D, 0xFF, 0x3F, 0xFF, 0x3F,
    0xFB, 0x30, 0xFB, 0x30, 0x20, 0x21, 0x21, 0x21, 0xB5, 0x10, 0xB5, 0x10,
    0x00, 0x00, 0xFF, 0xFF, 0x4B, 0xEF, 0x4B, 0xEF, 0xE0, 0xDE, 0xE0, 0xDE,
    0x05, 0xCF, 0x05, 0xCF, 0x00, 0xC0, 0x00, 0xC0, 0x14, 0xB2, 0x14, 0xB2,
    0x7D, 0xA5, 0x7F, 0xA5, 0x74, 0x9A, 0x75, 0x9A, 0x27, 0x91, 0x26, 0x91,
    0xC0, 0x89, 0xBF, 0x89, 0x5E, 0x84, 0x5D, 0x84, 0x19, 0x81, 0x19, 0x81,
    0x02, 0x80, 0x02, 0x80, 0x19, 0x81, 0x19, 0x81, 0x5E, 0x84, 0x5E, 0x84,
    0xBF, 0x89, 0xBF, 0x89, 0x27, 0x91, 0x28, 0x91, 0x75, 0x9A, 0x74, 0x9A,
    0x7E, 0xA5, 0x7E, 0xA5, 0x15, 0xB2, 0x15, 0xB2, 0x00, 0xC0, 0x00, 0xC0,
    0x04, 0xCF, 0x04, 0xCF, 0xDF, 0xDE, 0xDF, 0xDE, 0x4B, 0xEF, 0x4B, 0xEF
};

static unsigned char stone1k_m4dB_48kHz[192] =
{
    0x00, 0x00, 0x00, 0x00, 0x8A, 0x0A, 0x8B, 0x0A, 0xE6, 0x14, 0xE7, 0x14,
    0xE7, 0x1E, 0xE7, 0x1E, 0x61, 0x28, 0x62, 0x28, 0x29, 0x31, 0x2B, 0x31,
    0x1A, 0x39, 0x1B, 0x39, 0x12, 0x40, 0x12, 0x40, 0xF1, 0x45, 0xF1, 0x45,
    0x9D, 0x4A, 0x9D, 0x4A, 0x02, 0x4E, 0x02, 0x4E, 0x11, 0x50, 0x12, 0x50,
    0xC3, 0x50, 0xC3, 0x50, 0x12, 0x50, 0x11, 0x50, 0x03, 0x4E, 0x02, 0x4E,
    0x9D, 0x4A, 0x9D, 0x4A, 0xF1, 0x45, 0xF1, 0x45, 0x13, 0x40, 0x12, 0x40,
    0x1B, 0x39, 0x1B, 0x39, 0x29, 0x31, 0x2A, 0x31, 0x62, 0x28, 0x62, 0x28,
    0xE8, 0x1E, 0xE7, 0x1E, 0xE7, 0x14, 0xE6, 0x14, 0x8B, 0x0A, 0x8B, 0x0A,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xF5, 0x76, 0xF5, 0x19, 0xEB, 0x19, 0xEB,
    0x18, 0xE1, 0x19, 0xE1, 0x9E, 0xD7, 0x9E, 0xD7, 0xD6, 0xCE, 0xD6, 0xCE,
    0xE6, 0xC6, 0xE5, 0xC6, 0xEE, 0xBF, 0xEE, 0xBF, 0x0F, 0xBA, 0x0F, 0xBA,
    0x64, 0xB5, 0x64, 0xB5, 0xFE, 0xB1, 0xFE, 0xB1, 0xEE, 0xAF, 0xEF, 0xAF,
    0x3D, 0xAF, 0x3D, 0xAF, 0xEF, 0xAF, 0xEE, 0xAF, 0xFE, 0xB1, 0xFE, 0xB1,
    0x63, 0xB5, 0x63, 0xB5, 0x0F, 0xBA, 0x10, 0xBA, 0xED, 0xBF, 0xEE, 0xBF,
    0xE4, 0xC6, 0xE6, 0xC6, 0xD6, 0xCE, 0xD6, 0xCE, 0x9F, 0xD7, 0x9F, 0xD7,
    0x19, 0xE1, 0x18, 0xE1, 0x1A, 0xEB, 0x19, 0xEB, 0x75, 0xF5, 0x76, 0xF5
};

unsigned char stone1k_m8dB_48kHz[192] =
{
    0x01, 0x00, 0xFF, 0xFF, 0xA7, 0x06, 0xA6, 0x06, 0x31, 0x0D, 0x31, 0x0D,
    0x80, 0x13, 0x80, 0x13, 0x7A, 0x19, 0x7A, 0x19, 0x05, 0x1F, 0x05, 0x1F,
    0x08, 0x24, 0x08, 0x24, 0x6D, 0x28, 0x6D, 0x28, 0x21, 0x2C, 0x22, 0x2C,
    0x14, 0x2F, 0x14, 0x2F, 0x38, 0x31, 0x39, 0x31, 0x85, 0x32, 0x86, 0x32,
    0xF6, 0x32, 0xF5, 0x32, 0x85, 0x32, 0x85, 0x32, 0x37, 0x31, 0x39, 0x31,
    0x14, 0x2F, 0x14, 0x2F, 0x21, 0x2C, 0x21, 0x2C, 0x6D, 0x28, 0x6D, 0x28,
    0x07, 0x24, 0x08, 0x24, 0x05, 0x1F, 0x05, 0x1F, 0x7A, 0x19, 0x7B, 0x19,
    0x81, 0x13, 0x81, 0x13, 0x30, 0x0D, 0x31, 0x0D, 0xA6, 0x06, 0xA7, 0x06,
    0xFF, 0xFF, 0x00, 0x00, 0x5A, 0xF9, 0x59, 0xF9, 0xD0, 0xF2, 0xD0, 0xF2,
    0x80, 0xEC, 0x80, 0xEC, 0x86, 0xE6, 0x86, 0xE6, 0xFB, 0xE0, 0xFB, 0xE0,
    0xF7, 0xDB, 0xF8, 0xDB, 0x93, 0xD7, 0x93, 0xD7, 0xDF, 0xD3, 0xDF, 0xD3,
    0xEC, 0xD0, 0xEC, 0xD0, 0xC7, 0xCE, 0xC8, 0xCE, 0x7A, 0xCD, 0x7B, 0xCD,
    0x0B, 0xCD, 0x0B, 0xCD, 0x7B, 0xCD, 0x7A, 0xCD, 0xC8, 0xCE, 0xC8, 0xCE,
    0xED, 0xD0, 0xEC, 0xD0, 0xDF, 0xD3, 0xDE, 0xD3, 0x93, 0xD7, 0x92, 0xD7,
    0xF8, 0xDB, 0xF8, 0xDB, 0xFB, 0xE0, 0xFB, 0xE0, 0x86, 0xE6, 0x86, 0xE6,
    0x80, 0xEC, 0x81, 0xEC, 0xD0, 0xF2, 0xD0, 0xF2, 0x5A, 0xF9, 0x59, 0xF9
};

static unsigned char stone2k_48kHz[96] =
{
    0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x21, 0x21, 0x00, 0x40, 0xFF, 0x3F,
    0x82, 0x5A, 0x83, 0x5A, 0xD9, 0x6E, 0xD9, 0x6E, 0xA2, 0x7B, 0xA3, 0x7B,
    0xFE, 0x7F, 0xFE, 0x7F, 0xA2, 0x7B, 0xA2, 0x7B, 0xD9, 0x6E, 0xD9, 0x6E,
    0x82, 0x5A, 0x82, 0x5A, 0x00, 0x40, 0x00, 0x40, 0x21, 0x21, 0x20, 0x21,
    0x00, 0x00, 0x00, 0x00, 0xE0, 0xDE, 0xDF, 0xDE, 0x00, 0xC0, 0x01, 0xC0,
    0x7E, 0xA5, 0x7E, 0xA5, 0x27, 0x91, 0x27, 0x91, 0x5E, 0x84, 0x5E, 0x84,
    0x01, 0x80, 0x01, 0x80, 0x5E, 0x84, 0x5D, 0x84, 0x27, 0x91, 0x26, 0x91,
    0x7E, 0xA5, 0x7E, 0xA5, 0x00, 0xC0, 0x01, 0xC0, 0xE0, 0xDE, 0xDF, 0xDE
};

static unsigned char stone2k_m4dB_48kHz[96] =
{
    0x00, 0x00, 0x00, 0x00, 0xE8, 0x14, 0xE8, 0x14, 0x62, 0x28, 0x61, 0x28,
    0x1C, 0x39, 0x1B, 0x39, 0xF0, 0x45, 0xF1, 0x45, 0x03, 0x4E, 0x01, 0x4E,
    0xC2, 0x50, 0xC3, 0x50, 0x02, 0x4E, 0x02, 0x4E, 0xF1, 0x45, 0xF1, 0x45,
    0x1B, 0x39, 0x1B, 0x39, 0x61, 0x28, 0x61, 0x28, 0xE6, 0x14, 0xE6, 0x14,
    0xFF, 0xFF, 0x00, 0x00, 0x1A, 0xEB, 0x1A, 0xEB, 0x9E, 0xD7, 0x9F, 0xD7,
    0xE5, 0xC6, 0xE5, 0xC6, 0x0F, 0xBA, 0x0F, 0xBA, 0xFE, 0xB1, 0xFE, 0xB1,
    0x3E, 0xAF, 0x3D, 0xAF, 0xFD, 0xB1, 0xFE, 0xB1, 0x10, 0xBA, 0x0F, 0xBA,
    0xE5, 0xC6, 0xE5, 0xC6, 0x9F, 0xD7, 0x9E, 0xD7, 0x19, 0xEB, 0x19, 0xEB
};

static unsigned char stone3k_48kHz[64] =
{
    0x00, 0x00, 0x00, 0x00, 0xFB, 0x30, 0xFB, 0x30, 0x82, 0x5A, 0x82, 0x5A,
    0x41, 0x76, 0x41, 0x76, 0xFF, 0x7F, 0xFF, 0x7F, 0x40, 0x76, 0x41, 0x76,
    0x82, 0x5A, 0x82, 0x5A, 0xFB, 0x30, 0xFC, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x05, 0xCF, 0x05, 0xCF, 0x7E, 0xA5, 0x7E, 0xA5, 0xBF, 0x89, 0xBF, 0x89,
    0x01, 0x80, 0x01, 0x80, 0xC0, 0x89, 0xC0, 0x89, 0x7D, 0xA5, 0x7E, 0xA5,
    0x05, 0xCF, 0x04, 0xCF
};

static unsigned char stone3k_m4dB_48kHz[64] =
{
    0x00, 0x00, 0xFF, 0xFF, 0xE8, 0x1E, 0xE8, 0x1E, 0x1B, 0x39, 0x1B, 0x39,
    0x9D, 0x4A, 0x9D, 0x4A, 0xC3, 0x50, 0xC2, 0x50, 0x9D, 0x4A, 0x9D, 0x4A,
    0x1A, 0x39, 0x1B, 0x39, 0xE8, 0x1E, 0xE7, 0x1E, 0x00, 0x00, 0x01, 0x00,
    0x18, 0xE1, 0x18, 0xE1, 0xE6, 0xC6, 0xE5, 0xC6, 0x63, 0xB5, 0x63, 0xB5,
    0x3E, 0xAF, 0x3D, 0xAF, 0x63, 0xB5, 0x63, 0xB5, 0xE5, 0xC6, 0xE5, 0xC6,
    0x18, 0xE1, 0x19, 0xE1
};

static unsigned char stone4k_48kHz[48] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0xD9, 0x6E, 0xD9, 0x6E,
    0xFF, 0x7F, 0xFF, 0x7F, 0xD9, 0x6E, 0xD9, 0x6E, 0xFF, 0x3F, 0xFF, 0x3F,
    0x01, 0x00, 0xFF, 0xFF, 0x01, 0xC0, 0x01, 0xC0, 0x27, 0x91, 0x27, 0x91,
    0x00, 0x80, 0x01, 0x80, 0x27, 0x91, 0x27, 0x91, 0x00, 0xC0, 0x00, 0xC0
};

static unsigned char stone4k_m4dB_48kHz[48] =
{
    0x00, 0x00, 0x01, 0x00, 0x61, 0x28, 0x61, 0x28, 0xF0, 0x45, 0xF1, 0x45,
    0xC2, 0x50, 0xC2, 0x50, 0xF1, 0x45, 0xF1, 0x45, 0x62, 0x28, 0x62, 0x28,
    0x00, 0x00, 0xFF, 0xFF, 0x9F, 0xD7, 0x9F, 0xD7, 0x0F, 0xBA, 0x0F, 0xBA,
    0x3E, 0xAF, 0x3E, 0xAF, 0x0F, 0xBA, 0x10, 0xBA, 0x9F, 0xD7, 0x9F, 0xD7
};

static unsigned char stone5k_48kHz[192] =
{
    0x00, 0x00, 0x00, 0x00, 0xEC, 0x4D, 0xEB, 0x4D, 0xA3, 0x7B, 0xA2, 0x7B,
    0x41, 0x76, 0x41, 0x76, 0xFF, 0x3F, 0xFF, 0x3F, 0x4C, 0xEF, 0x4B, 0xEF,
    0x7F, 0xA5, 0x7E, 0xA5, 0x19, 0x81, 0x19, 0x81, 0x27, 0x91, 0x27, 0x91,
    0x05, 0xCF, 0x05, 0xCF, 0x21, 0x21, 0x20, 0x21, 0x8C, 0x65, 0x8D, 0x65,
    0xFF, 0x7F, 0xFF, 0x7F, 0x8C, 0x65, 0x8C, 0x65, 0x21, 0x21, 0x21, 0x21,
    0x05, 0xCF, 0x04, 0xCF, 0x27, 0x91, 0x27, 0x91, 0x1A, 0x81, 0x19, 0x81,
    0x7E, 0xA5, 0x7E, 0xA5, 0x4B, 0xEF, 0x4B, 0xEF, 0xFF, 0x3F, 0xFF, 0x3F,
    0x41, 0x76, 0x41, 0x76, 0xA2, 0x7B, 0xA2, 0x7B, 0xEB, 0x4D, 0xEC, 0x4D,
    0x00, 0x00, 0x01, 0x00, 0x15, 0xB2, 0x14, 0xB2, 0x5E, 0x84, 0x5E, 0x84,
    0xBF, 0x89, 0xBF, 0x89, 0x01, 0xC0, 0x00, 0xC0, 0xB5, 0x10, 0xB6, 0x10,
    0x81, 0x5A, 0x82, 0x5A, 0xE6, 0x7E, 0xE7, 0x7E, 0xD9, 0x6E, 0xDA, 0x6E,
    0xFC, 0x30, 0xFA, 0x30, 0xDF, 0xDE, 0xE0, 0xDE, 0x75, 0x9A, 0x74, 0x9A,
    0x01, 0x80, 0x01, 0x80, 0x73, 0x9A, 0x75, 0x9A, 0xE0, 0xDE, 0xDF, 0xDE,
    0xFB, 0x30, 0xFC, 0x30, 0xD9, 0x6E, 0xD9, 0x6E, 0xE7, 0x7E, 0xE6, 0x7E,
    0x81, 0x5A, 0x82, 0x5A, 0xB5, 0x10, 0xB5, 0x10, 0x00, 0xC0, 0x01, 0xC0,
    0xC0, 0x89, 0xC0, 0x89, 0x5D, 0x84, 0x5E, 0x84, 0x15, 0xB2, 0x15, 0xB2
};

static unsigned char stone5k_m4dB_48kHz[192] =
{
    0x00, 0x00, 0xFF, 0xFF, 0x2A, 0x31, 0x2A, 0x31, 0x02, 0x4E, 0x02, 0x4E,
    0x9E, 0x4A, 0x9D, 0x4A, 0x62, 0x28, 0x61, 0x28, 0x75, 0xF5, 0x76, 0xF5,
    0xE5, 0xC6, 0xE5, 0xC6, 0xEE, 0xAF, 0xEE, 0xAF, 0x10, 0xBA, 0x0F, 0xBA,
    0x18, 0xE1, 0x19, 0xE1, 0xE7, 0x14, 0xE7, 0x14, 0x13, 0x40, 0x12, 0x40,
    0xC3, 0x50, 0xC2, 0x50, 0x12, 0x40, 0x12, 0x40, 0xE7, 0x14, 0xE6, 0x14,
    0x18, 0xE1, 0x19, 0xE1, 0x10, 0xBA, 0x10, 0xBA, 0xEE, 0xAF, 0xEE, 0xAF,
    0xE5, 0xC6, 0xE5, 0xC6, 0x76, 0xF5, 0x75, 0xF5, 0x61, 0x28, 0x61, 0x28,
    0x9D, 0x4A, 0x9D, 0x4A, 0x02, 0x4E, 0x02, 0x4E, 0x2A, 0x31, 0x29, 0x31,
    0x00, 0x00, 0x00, 0x00, 0xD6, 0xCE, 0xD7, 0xCE, 0xFE, 0xB1, 0xFE, 0xB1,
    0x64, 0xB5, 0x63, 0xB5, 0xA0, 0xD7, 0x9F, 0xD7, 0x8A, 0x0A, 0x8A, 0x0A,
    0x1B, 0x39, 0x1B, 0x39, 0x11, 0x50, 0x12, 0x50, 0xF1, 0x45, 0xF0, 0x45,
    0xE8, 0x1E, 0xE8, 0x1E, 0x19, 0xEB, 0x19, 0xEB, 0xEE, 0xBF, 0xEE, 0xBF,
    0x3D, 0xAF, 0x3D, 0xAF, 0xED, 0xBF, 0xED, 0xBF, 0x19, 0xEB, 0x1A, 0xEB,
    0xE7, 0x1E, 0xE8, 0x1E, 0xF1, 0x45, 0xF0, 0x45, 0x12, 0x50, 0x12, 0x50,
    0x1B, 0x39, 0x1A, 0x39, 0x8B, 0x0A, 0x8A, 0x0A, 0x9E, 0xD7, 0x9F, 0xD7,
    0x63, 0xB5, 0x63, 0xB5, 0xFF, 0xB1, 0xFE, 0xB1, 0xD6, 0xCE, 0xD7, 0xCE
};

static unsigned char stone6k_48kHz[32] =
{
    0x00, 0x00, 0x00, 0x00, 0x82, 0x5A, 0x82, 0x5A, 0xFF, 0x7F, 0xFF, 0x7F,
    0x82, 0x5A, 0x82, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xA5, 0x7E, 0xA5,
    0x02, 0x80, 0x01, 0x80, 0x7F, 0xA5, 0x7F, 0xA5
};

static unsigned char stone6k_m4dB_48kHz[32] =
{
    0xFF, 0xFF, 0x00, 0x00, 0x1B, 0x39, 0x1B, 0x39, 0xC3, 0x50, 0xC3, 0x50,
    0x1B, 0x39, 0x1C, 0x39, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xC6, 0xE5, 0xC6,
    0x3D, 0xAF, 0x3E, 0xAF, 0xE4, 0xC6, 0xE4, 0xC6
};

static unsigned char stone7k_48kHz[192] =
{
    0x00, 0x00, 0xFF, 0xFF, 0x8B, 0x65, 0x8B, 0x65, 0xA2, 0x7B, 0xA3, 0x7B,
    0xFB, 0x30, 0xFB, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x19, 0x81, 0x19, 0x81,
    0x7F, 0xA5, 0x7E, 0xA5, 0xB5, 0x10, 0xB5, 0x10, 0xD8, 0x6E, 0xD9, 0x6E,
    0x41, 0x76, 0x41, 0x76, 0x20, 0x21, 0x21, 0x21, 0x14, 0xB2, 0x15, 0xB2,
    0x01, 0x80, 0x01, 0x80, 0x15, 0xB2, 0x14, 0xB2, 0x21, 0x21, 0x21, 0x21,
    0x40, 0x76, 0x41, 0x76, 0xD9, 0x6E, 0xD9, 0x6E, 0xB5, 0x10, 0xB5, 0x10,
    0x7D, 0xA5, 0x7E, 0xA5, 0x19, 0x81, 0x1A, 0x81, 0x01, 0xC0, 0x00, 0xC0,
    0xFB, 0x30, 0xFC, 0x30, 0xA3, 0x7B, 0xA3, 0x7B, 0x8C, 0x65, 0x8B, 0x65,
    0x01, 0x00, 0xFF, 0xFF, 0x75, 0x9A, 0x73, 0x9A, 0x5D, 0x84, 0x5E, 0x84,
    0x05, 0xCF, 0x05, 0xCF, 0xFF, 0x3F, 0xFF, 0x3F, 0xE6, 0x7E, 0xE7, 0x7E,
    0x82, 0x5A, 0x81, 0x5A, 0x4C, 0xEF, 0x4B, 0xEF, 0x27, 0x91, 0x27, 0x91,
    0xBE, 0x89, 0xBF, 0x89, 0xE0, 0xDE, 0xDF, 0xDE, 0xEC, 0x4D, 0xEB, 0x4D,
    0xFF, 0x7F, 0xFF, 0x7F, 0xEB, 0x4D, 0xEC, 0x4D, 0xDF, 0xDE, 0xE0, 0xDE,
    0xC0, 0x89, 0xBF, 0x89, 0x27, 0x91, 0x28, 0x91, 0x4B, 0xEF, 0x4B, 0xEF,
    0x82, 0x5A, 0x82, 0x5A, 0xE7, 0x7E, 0xE7, 0x7E, 0xFF, 0x3F, 0x00, 0x40,
    0x05, 0xCF, 0x04, 0xCF, 0x5E, 0x84, 0x5D, 0x84, 0x75, 0x9A, 0x74, 0x9A
};

static unsigned char stone7k_m4dB_48kHz[192] =
{
    0x00, 0x00, 0x00, 0x00, 0x13, 0x40, 0x12, 0x40, 0x02, 0x4E, 0x02, 0x4E,
    0xE9, 0x1E, 0xE8, 0x1E, 0x9E, 0xD7, 0x9F, 0xD7, 0xEE, 0xAF, 0xEF, 0xAF,
    0xE5, 0xC6, 0xE5, 0xC6, 0x8B, 0x0A, 0x8B, 0x0A, 0xF1, 0x45, 0xF1, 0x45,
    0x9C, 0x4A, 0x9D, 0x4A, 0xE7, 0x14, 0xE7, 0x14, 0xD6, 0xCE, 0xD7, 0xCE,
    0x3E, 0xAF, 0x3D, 0xAF, 0xD6, 0xCE, 0xD7, 0xCE, 0xE6, 0x14, 0xE7, 0x14,
    0x9D, 0x4A, 0x9D, 0x4A, 0xF1, 0x45, 0xF1, 0x45, 0x8A, 0x0A, 0x8A, 0x0A,
    0xE6, 0xC6, 0xE5, 0xC6, 0xEF, 0xAF, 0xEE, 0xAF, 0x9F, 0xD7, 0x9F, 0xD7,
    0xE7, 0x1E, 0xE9, 0x1E, 0x03, 0x4E, 0x02, 0x4E, 0x12, 0x40, 0x12, 0x40,
    0x00, 0x00, 0x00, 0x00, 0xEF, 0xBF, 0xEE, 0xBF, 0xFE, 0xB1, 0xFE, 0xB1,
    0x18, 0xE1, 0x19, 0xE1, 0x61, 0x28, 0x61, 0x28, 0x11, 0x50, 0x11, 0x50,
    0x1B, 0x39, 0x1B, 0x39, 0x76, 0xF5, 0x75, 0xF5, 0x10, 0xBA, 0x0F, 0xBA,
    0x63, 0xB5, 0x63, 0xB5, 0x19, 0xEB, 0x19, 0xEB, 0x2A, 0x31, 0x29, 0x31,
    0xC3, 0x50, 0xC3, 0x50, 0x2A, 0x31, 0x2B, 0x31, 0x19, 0xEB, 0x19, 0xEB,
    0x64, 0xB5, 0x63, 0xB5, 0x10, 0xBA, 0x0F, 0xBA, 0x75, 0xF5, 0x76, 0xF5,
    0x1B, 0x39, 0x1B, 0x39, 0x12, 0x50, 0x11, 0x50, 0x61, 0x28, 0x61, 0x28,
    0x18, 0xE1, 0x19, 0xE1, 0xFE, 0xB1, 0xFD, 0xB1, 0xEE, 0xBF, 0xED, 0xBF
};

static unsigned char stone8k_48kHz[24] =
{
    0x00, 0x00, 0x01, 0x00, 0xDA, 0x6E, 0xD8, 0x6E, 0xD9, 0x6E, 0xDA, 0x6E,
    0x00, 0x00, 0x00, 0x00, 0x27, 0x91, 0x26, 0x91, 0x27, 0x91, 0x27, 0x91
};

static unsigned char stone8k_m4dB_48kHz[24] =
{
    0x00, 0x00, 0x01, 0x00, 0xF1, 0x45, 0xF1, 0x45, 0xF1, 0x45, 0xF1, 0x45,
    0xFF, 0xFF, 0x01, 0x00, 0x10, 0xBA, 0x0F, 0xBA, 0x0F, 0xBA, 0x0F, 0xBA
};

static unsigned char stone9k_48kHz[64] =
{
    0x00, 0x00, 0x00, 0x00, 0x40, 0x76, 0x41, 0x76, 0x82, 0x5A, 0x82, 0x5A,
    0x04, 0xCF, 0x04, 0xCF, 0x00, 0x80, 0x01, 0x80, 0x04, 0xCF, 0x04, 0xCF,
    0x82, 0x5A, 0x82, 0x5A, 0x40, 0x76, 0x41, 0x76, 0x00, 0x00, 0xFF, 0xFF,
    0xC0, 0x89, 0xBF, 0x89, 0x7D, 0xA5, 0x7E, 0xA5, 0xFB, 0x30, 0xFB, 0x30,
    0xFF, 0x7F, 0xFF, 0x7F, 0xFC, 0x30, 0xFB, 0x30, 0x7E, 0xA5, 0x7E, 0xA5,
    0xC0, 0x89, 0xBF, 0x89
};

static unsigned char stone9k_m4dB_48kHz[64] =
{
    0x00, 0x00, 0x01, 0x00, 0x9D, 0x4A, 0x9D, 0x4A, 0x1B, 0x39, 0x1B, 0x39,
    0x18, 0xE1, 0x18, 0xE1, 0x3D, 0xAF, 0x3D, 0xAF, 0x19, 0xE1, 0x18, 0xE1,
    0x1B, 0x39, 0x1B, 0x39, 0x9C, 0x4A, 0x9D, 0x4A, 0x00, 0x00, 0x00, 0x00,
    0x63, 0xB5, 0x63, 0xB5, 0xE4, 0xC6, 0xE5, 0xC6, 0xE8, 0x1E, 0xE8, 0x1E,
    0xC3, 0x50, 0xC3, 0x50, 0xE8, 0x1E, 0xE8, 0x1E, 0xE5, 0xC6, 0xE5, 0xC6,
    0x63, 0xB5, 0x63, 0xB5
};

static unsigned char stone10k_48kHz[96] =
{
    0x00, 0x00, 0x00, 0x00, 0xA2, 0x7B, 0xA3, 0x7B, 0x00, 0x40, 0xFF, 0x3F,
    0x7E, 0xA5, 0x7E, 0xA5, 0x27, 0x91, 0x26, 0x91, 0x21, 0x21, 0x21, 0x21,
    0xFF, 0x7F, 0xFF, 0x7F, 0x21, 0x21, 0x20, 0x21, 0x27, 0x91, 0x27, 0x91,
    0x7F, 0xA5, 0x7D, 0xA5, 0x00, 0x40, 0x00, 0x40, 0xA3, 0x7B, 0xA3, 0x7B,
    0x00, 0x00, 0x00, 0x00, 0x5E, 0x84, 0x5E, 0x84, 0x00, 0xC0, 0x01, 0xC0,
    0x82, 0x5A, 0x82, 0x5A, 0xD9, 0x6E, 0xD9, 0x6E, 0xDF, 0xDE, 0xE0, 0xDE,
    0x01, 0x80, 0x00, 0x80, 0xDF, 0xDE, 0xDF, 0xDE, 0xD9, 0x6E, 0xD9, 0x6E,
    0x82, 0x5A, 0x82, 0x5A, 0x01, 0xC0, 0x01, 0xC0, 0x5E, 0x84, 0x5D, 0x84
};

static unsigned char stone10k_m4dB_48kHz[96] =
{
    0x00, 0x00, 0xFF, 0xFF, 0x02, 0x4E, 0x01, 0x4E, 0x61, 0x28, 0x61, 0x28,
    0xE5, 0xC6, 0xE5, 0xC6, 0x10, 0xBA, 0x0E, 0xBA, 0xE7, 0x14, 0xE7, 0x14,
    0xC2, 0x50, 0xC3, 0x50, 0xE7, 0x14, 0xE6, 0x14, 0x10, 0xBA, 0x0F, 0xBA,
    0xE5, 0xC6, 0xE4, 0xC6, 0x61, 0x28, 0x61, 0x28, 0x02, 0x4E, 0x02, 0x4E,
    0x00, 0x00, 0xFF, 0xFF, 0xFE, 0xB1, 0xFE, 0xB1, 0x9F, 0xD7, 0x9F, 0xD7,
    0x1C, 0x39, 0x1C, 0x39, 0xF1, 0x45, 0xF1, 0x45, 0x18, 0xEB, 0x19, 0xEB,
    0x3E, 0xAF, 0x3D, 0xAF, 0x19, 0xEB, 0x1A, 0xEB, 0xF0, 0x45, 0xF1, 0x45,
    0x1C, 0x39, 0x1A, 0x39, 0x9F, 0xD7, 0x9F, 0xD7, 0xFD, 0xB1, 0xFE, 0xB1
};

static unsigned char stone11k_48kHz[192] =
{
    0x00, 0x00, 0xFF, 0xFF, 0xE7, 0x7E, 0xE6, 0x7E, 0x20, 0x21, 0x21, 0x21,
    0xBE, 0x89, 0xBF, 0x89, 0x01, 0xC0, 0x01, 0xC0, 0x8C, 0x65, 0x8C, 0x65,
    0x82, 0x5A, 0x81, 0x5A, 0x14, 0xB2, 0x14, 0xB2, 0x27, 0x91, 0x27, 0x91,
    0xFB, 0x30, 0xFB, 0x30, 0xA3, 0x7B, 0xA2, 0x7B, 0x4B, 0xEF, 0x4B, 0xEF,
    0x01, 0x80, 0x01, 0x80, 0x4A, 0xEF, 0x4C, 0xEF, 0xA3, 0x7B, 0xA2, 0x7B,
    0xFB, 0x30, 0xFB, 0x30, 0x26, 0x91, 0x27, 0x91, 0x14, 0xB2, 0x15, 0xB2,
    0x82, 0x5A, 0x82, 0x5A, 0x8B, 0x65, 0x8C, 0x65, 0x00, 0xC0, 0x01, 0xC0,
    0xBF, 0x89, 0xBF, 0x89, 0x21, 0x21, 0x20, 0x21, 0xE7, 0x7E, 0xE7, 0x7E,
    0x01, 0x00, 0xFF, 0xFF, 0x19, 0x81, 0x1A, 0x81, 0xDF, 0xDE, 0xDF, 0xDE,
    0x41, 0x76, 0x41, 0x76, 0x00, 0x40, 0x00, 0x40, 0x74, 0x9A, 0x74, 0x9A,
    0x7E, 0xA5, 0x7E, 0xA5, 0xEB, 0x4D, 0xEB, 0x4D, 0xD9, 0x6E, 0xD9, 0x6E,
    0x05, 0xCF, 0x05, 0xCF, 0x5E, 0x84, 0x5D, 0x84, 0xB5, 0x10, 0xB4, 0x10,
    0xFE, 0x7F, 0xFF, 0x7F, 0xB4, 0x10, 0xB6, 0x10, 0x5E, 0x84, 0x5D, 0x84,
    0x04, 0xCF, 0x04, 0xCF, 0xDA, 0x6E, 0xD9, 0x6E, 0xEB, 0x4D, 0xEB, 0x4D,
    0x7E, 0xA5, 0x7E, 0xA5, 0x74, 0x9A, 0x74, 0x9A, 0x00, 0x40, 0x00, 0x40,
    0x40, 0x76, 0x41, 0x76, 0xDF, 0xDE, 0xDF, 0xDE, 0x19, 0x81, 0x19, 0x81
};

static unsigned char stone11k_m4dB_48kHz[192] =
{
    0x01, 0x00, 0x00, 0x00, 0x12, 0x50, 0x11, 0x50, 0xE7, 0x14, 0xE6, 0x14,
    0x63, 0xB5, 0x63, 0xB5, 0x9F, 0xD7, 0x9F, 0xD7, 0x12, 0x40, 0x12, 0x40,
    0x1B, 0x39, 0x1B, 0x39, 0xD6, 0xCE, 0xD6, 0xCE, 0x0F, 0xBA, 0x0F, 0xBA,
    0xE8, 0x1E, 0xE8, 0x1E, 0x02, 0x4E, 0x02, 0x4E, 0x75, 0xF5, 0x76, 0xF5,
    0x3D, 0xAF, 0x3D, 0xAF, 0x75, 0xF5, 0x75, 0xF5, 0x02, 0x4E, 0x03, 0x4E,
    0xE7, 0x1E, 0xE8, 0x1E, 0x0F, 0xBA, 0x0F, 0xBA, 0xD6, 0xCE, 0xD6, 0xCE,
    0x1B, 0x39, 0x1C, 0x39, 0x12, 0x40, 0x12, 0x40, 0x9F, 0xD7, 0x9F, 0xD7,
    0x63, 0xB5, 0x64, 0xB5, 0xE7, 0x14, 0xE6, 0x14, 0x12, 0x50, 0x12, 0x50,
    0x01, 0x00, 0x00, 0x00, 0xEE, 0xAF, 0xEE, 0xAF, 0x19, 0xEB, 0x19, 0xEB,
    0x9D, 0x4A, 0x9D, 0x4A, 0x61, 0x28, 0x61, 0x28, 0xED, 0xBF, 0xEE, 0xBF,
    0xE5, 0xC6, 0xE5, 0xC6, 0x2A, 0x31, 0x29, 0x31, 0xF0, 0x45, 0xF1, 0x45,
    0x18, 0xE1, 0x19, 0xE1, 0xFD, 0xB1, 0xFE, 0xB1, 0x8B, 0x0A, 0x8B, 0x0A,
    0xC2, 0x50, 0xC3, 0x50, 0x8A, 0x0A, 0x8A, 0x0A, 0xFE, 0xB1, 0xFF, 0xB1,
    0x18, 0xE1, 0x18, 0xE1, 0xF1, 0x45, 0xF1, 0x45, 0x2A, 0x31, 0x29, 0x31,
    0xE5, 0xC6, 0xE5, 0xC6, 0xED, 0xBF, 0xEE, 0xBF, 0x61, 0x28, 0x62, 0x28,
    0x9D, 0x4A, 0x9D, 0x4A, 0x18, 0xEB, 0x1A, 0xEB, 0xEE, 0xAF, 0xEE, 0xAF
};

static unsigned char stone12k_48kHz[64] =
{
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0xFF, 0x00, 0x00,
    0x01, 0x80, 0x01, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x7F, 0xFE, 0x7F,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x80, 0xFF, 0xFF, 0x00, 0x00,
    0xFF, 0x7F, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x01, 0x80,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x80, 0x01, 0x80
};

static unsigned char stone12k_m4dB_48kHz[64] =
{
    0x00, 0x00, 0x00, 0x00, 0xC3, 0x50, 0xC2, 0x50, 0xFF, 0xFF, 0x00, 0x00,
    0x3D, 0xAF, 0x3D, 0xAF, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x50, 0xC2, 0x50,
    0x01, 0x00, 0x00, 0x00, 0x3E, 0xAF, 0x3D, 0xAF, 0x00, 0x00, 0x00, 0x00,
    0xC2, 0x50, 0xC3, 0x50, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xAF, 0x3E, 0xAF,
    0x00, 0x00, 0x01, 0x00, 0xC3, 0x50, 0xC3, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0xAF, 0x3D, 0xAF
};

static unsigned char stone13k_48kHz[192] =
{
    0x01, 0x00, 0x01, 0x00, 0xE6, 0x7E, 0xE7, 0x7E, 0xDF, 0xDE, 0xE0, 0xDE,
    0xBF, 0x89, 0xBF, 0x89, 0xFF, 0x3F, 0x00, 0x40, 0x8C, 0x65, 0x8C, 0x65,
    0x7E, 0xA5, 0x7E, 0xA5, 0x15, 0xB2, 0x14, 0xB2, 0xD8, 0x6E, 0xD9, 0x6E,
    0xFB, 0x30, 0xFC, 0x30, 0x5E, 0x84, 0x5E, 0x84, 0x4B, 0xEF, 0x4B, 0xEF,
    0xFF, 0x7F, 0xFF, 0x7F, 0x4B, 0xEF, 0x4B, 0xEF, 0x5E, 0x84, 0x5E, 0x84,
    0xFC, 0x30, 0xFB, 0x30, 0xD9, 0x6E, 0xD9, 0x6E, 0x15, 0xB2, 0x15, 0xB2,
    0x7E, 0xA5, 0x7F, 0xA5, 0x8C, 0x65, 0x8B, 0x65, 0x00, 0x40, 0xFF, 0x3F,
    0xC0, 0x89, 0xBF, 0x89, 0xDF, 0xDE, 0xDF, 0xDE, 0xE7, 0x7E, 0xE7, 0x7E,
    0x00, 0x00, 0x00, 0x00, 0x19, 0x81, 0x19, 0x81, 0x20, 0x21, 0x20, 0x21,
    0x41, 0x76, 0x41, 0x76, 0x00, 0xC0, 0x01, 0xC0, 0x75, 0x9A, 0x75, 0x9A,
    0x81, 0x5A, 0x81, 0x5A, 0xEB, 0x4D, 0xEB, 0x4D, 0x27, 0x91, 0x27, 0x91,
    0x04, 0xCF, 0x05, 0xCF, 0xA3, 0x7B, 0xA3, 0x7B, 0xB5, 0x10, 0xB5, 0x10,
    0x02, 0x80, 0x01, 0x80, 0xB5, 0x10, 0xB5, 0x10, 0xA3, 0x7B, 0xA2, 0x7B,
    0x05, 0xCF, 0x05, 0xCF, 0x27, 0x91, 0x26, 0x91, 0xEC, 0x4D, 0xEC, 0x4D,
    0x82, 0x5A, 0x82, 0x5A, 0x74, 0x9A, 0x74, 0x9A, 0x01, 0xC0, 0x00, 0xC0,
    0x40, 0x76, 0x41, 0x76, 0x21, 0x21, 0x21, 0x21, 0x19, 0x81, 0x19, 0x81
};

static unsigned char stone13k_m4dB_48kHz[192] =
{
    0x01, 0x00, 0x00, 0x00, 0x11, 0x50, 0x12, 0x50, 0x19, 0xEB, 0x19, 0xEB,
    0x64, 0xB5, 0x63, 0xB5, 0x62, 0x28, 0x61, 0x28, 0x12, 0x40, 0x12, 0x40,
    0xE5, 0xC6, 0xE5, 0xC6, 0xD5, 0xCE, 0xD6, 0xCE, 0xF1, 0x45, 0xF1, 0x45,
    0xE8, 0x1E, 0xE8, 0x1E, 0xFE, 0xB1, 0xFE, 0xB1, 0x75, 0xF5, 0x76, 0xF5,
    0xC3, 0x50, 0xC3, 0x50, 0x75, 0xF5, 0x76, 0xF5, 0xFE, 0xB1, 0xFD, 0xB1,
    0xE8, 0x1E, 0xE8, 0x1E, 0xF1, 0x45, 0xF0, 0x45, 0xD6, 0xCE, 0xD6, 0xCE,
    0xE5, 0xC6, 0xE4, 0xC6, 0x12, 0x40, 0x13, 0x40, 0x61, 0x28, 0x62, 0x28,
    0x63, 0xB5, 0x63, 0xB5, 0x1A, 0xEB, 0x19, 0xEB, 0x11, 0x50, 0x11, 0x50,
    0x00, 0x00, 0x00, 0x00, 0xEF, 0xAF, 0xEE, 0xAF, 0xE7, 0x14, 0xE6, 0x14,
    0x9D, 0x4A, 0x9D, 0x4A, 0x9E, 0xD7, 0x9E, 0xD7, 0xEE, 0xBF, 0xEE, 0xBF,
    0x1B, 0x39, 0x1B, 0x39, 0x29, 0x31, 0x2A, 0x31, 0x0F, 0xBA, 0x0F, 0xBA,
    0x18, 0xE1, 0x18, 0xE1, 0x03, 0x4E, 0x02, 0x4E, 0x8A, 0x0A, 0x8B, 0x0A,
    0x3D, 0xAF, 0x3E, 0xAF, 0x8B, 0x0A, 0x8A, 0x0A, 0x02, 0x4E, 0x02, 0x4E,
    0x18, 0xE1, 0x17, 0xE1, 0x0F, 0xBA, 0x10, 0xBA, 0x2A, 0x31, 0x2A, 0x31,
    0x1C, 0x39, 0x1B, 0x39, 0xEE, 0xBF, 0xED, 0xBF, 0x9F, 0xD7, 0x9E, 0xD7,
    0x9C, 0x4A, 0x9D, 0x4A, 0xE7, 0x14, 0xE7, 0x14, 0xEE, 0xAF, 0xEF, 0xAF
};

static unsigned char stone14k_48kHz[96] =
{
    0x01, 0x00, 0x00, 0x00, 0xA3, 0x7B, 0xA3, 0x7B, 0x01, 0xC0, 0x01, 0xC0,
    0x7E, 0xA5, 0x7E, 0xA5, 0xD9, 0x6E, 0xDA, 0x6E, 0x21, 0x21, 0x21, 0x21,
    0x00, 0x80, 0x01, 0x80, 0x21, 0x21, 0x21, 0x21, 0xD9, 0x6E, 0xDA, 0x6E,
    0x7F, 0xA5, 0x7E, 0xA5, 0x00, 0xC0, 0x01, 0xC0, 0xA3, 0x7B, 0xA3, 0x7B,
    0x00, 0x00, 0x00, 0x00, 0x5D, 0x84, 0x5E, 0x84, 0x00, 0x40, 0x00, 0x40,
    0x81, 0x5A, 0x82, 0x5A, 0x27, 0x91, 0x26, 0x91, 0xE0, 0xDE, 0xE0, 0xDE,
    0xFF, 0x7F, 0xFF, 0x7F, 0xE0, 0xDE, 0xDE, 0xDE, 0x27, 0x91, 0x26, 0x91,
    0x81, 0x5A, 0x82, 0x5A, 0x00, 0x40, 0x00, 0x40, 0x5D, 0x84, 0x5D, 0x84
};

static unsigned char stone14k_m4dB_48kHz[96] =
{
    0x00, 0x00, 0x00, 0x00, 0x02, 0x4E, 0x02, 0x4E, 0x9E, 0xD7, 0x9E, 0xD7,
    0xE5, 0xC6, 0xE5, 0xC6, 0xF0, 0x45, 0xF0, 0x45, 0xE7, 0x14, 0xE7, 0x14,
    0x3D, 0xAF, 0x3E, 0xAF, 0xE7, 0x14, 0xE6, 0x14, 0xF1, 0x45, 0xF1, 0x45,
    0xE5, 0xC6, 0xE5, 0xC6, 0x9F, 0xD7, 0x9F, 0xD7, 0x03, 0x4E, 0x02, 0x4E,
    0x00, 0x00, 0x00, 0x00, 0xFD, 0xB1, 0xFD, 0xB1, 0x61, 0x28, 0x62, 0x28,
    0x1B, 0x39, 0x1B, 0x39, 0x0F, 0xBA, 0x0F, 0xBA, 0x19, 0xEB, 0x1A, 0xEB,
    0xC3, 0x50, 0xC3, 0x50, 0x19, 0xEB, 0x1A, 0xEB, 0x0F, 0xBA, 0x0F, 0xBA,
    0x1B, 0x39, 0x1B, 0x39, 0x62, 0x28, 0x61, 0x28, 0xFE, 0xB1, 0xFD, 0xB1
};

static unsigned char stone15k_48kHz[64] =
{
    0x00, 0x00, 0x00, 0x00, 0x41, 0x76, 0x41, 0x76, 0x7E, 0xA5, 0x7E, 0xA5,
    0x05, 0xCF, 0x05, 0xCF, 0xFF, 0x7F, 0xFF, 0x7F, 0x05, 0xCF, 0x04, 0xCF,
    0x7E, 0xA5, 0x7E, 0xA5, 0x41, 0x76, 0x41, 0x76, 0x00, 0x00, 0x00, 0x00,
    0xBF, 0x89, 0xBF, 0x89, 0x82, 0x5A, 0x82, 0x5A, 0xFB, 0x30, 0xFB, 0x30,
    0x01, 0x80, 0x02, 0x80, 0xFB, 0x30, 0xFB, 0x30, 0x82, 0x5A, 0x81, 0x5A,
    0xBF, 0x89, 0xBF, 0x89
};

static unsigned char stone15k_m4dB_48kHz[64] =
{
    0xFF, 0xFF, 0x00, 0x00, 0x9D, 0x4A, 0x9D, 0x4A, 0xE4, 0xC6, 0xE4, 0xC6,
    0x18, 0xE1, 0x19, 0xE1, 0xC3, 0x50, 0xC3, 0x50, 0x18, 0xE1, 0x18, 0xE1,
    0xE6, 0xC6, 0xE4, 0xC6, 0x9D, 0x4A, 0x9C, 0x4A, 0x00, 0x00, 0x00, 0x00,
    0x64, 0xB5, 0x63, 0xB5, 0x1B, 0x39, 0x1B, 0x39, 0xE7, 0x1E, 0xE8, 0x1E,
    0x3D, 0xAF, 0x3E, 0xAF, 0xE8, 0x1E, 0xE8, 0x1E, 0x1B, 0x39, 0x1B, 0x39,
    0x62, 0xB5, 0x63, 0xB5
};


/*****************************************************************************
*                          D A T A   T Y P E S
******************************************************************************
*/
#define FTM_Audio_FMTx   0
#define FTM_Audio_HDMI   1


/*****************************************************************************
*                        F U N C T I O N   D E F I N I T I O N
******************************************************************************
*/

static struct mixer *mMixer; // TODO(Harvey): move it to AudioALSAHardwareResourceManager later

namespace android
{

AudioFtm *AudioFtm::mAudioFtm = 0;
AudioFtm *AudioFtm::getInstance()
{
    static AudioLock mGetInstanceLock;
    AudioAutoTimeoutLock _l(mGetInstanceLock);

    if (mAudioFtm == 0)
    {
        mAudioFtm = new AudioFtm();
    }
    ASSERT(mAudioFtm != NULL);
    return mAudioFtm;
}

AudioFtm::AudioFtm() :
    mStreamManager(AudioALSAStreamManager::getInstance()),
    mStreamOut(NULL),
    mStreamIn(NULL),
    mLoopbackManager(LoopbackManager::GetInstance()),
    mHardwareResourceManager(AudioALSAHardwareResourceManager::getInstance())
{
    ALOGD("%s()", __FUNCTION__);

    // TODO(Harvey): tmp, remove it later
    mMixer = AudioALSADriverUtility::getInstance()->getMixer();
    ALOGD("mMixer = %p", mMixer);
    ASSERT(mMixer != NULL);
}

AudioFtm::~AudioFtm()
{
    ALOGD("%s()", __FUNCTION__);
}

int AudioFtm::SineGenTest(char sinegen_test)
{
    ALOGD("%s(), sinegen_test = %d", __FUNCTION__, sinegen_test);

    if (sinegen_test) // enable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
    }

    return true;
}

void AudioFtm::WavGen_AudioRead(char *pBuffer, unsigned int bytes)
{
    int copysize, IdxAudioPattern_Next = 0, i;
    char *copybuffer = NULL;
    copybuffer = pBuffer;

    copysize = SizeAudioPattern - IdxAudioPattern;
    ALOGV("WavGen_AudioRead IdxAudioPattern=%d, SizeAudioPattern=%d, copysize=%d, bytes=%d,", IdxAudioPattern, SizeAudioPattern, copysize, bytes);

    while (bytes)
    {
        memcpy((void *)copybuffer, (void *)(mDataTable + IdxAudioPattern), copysize);
        bytes -= copysize;
        copybuffer += copysize;
        if (bytes >= SizeAudioPattern)
        {
            copysize = SizeAudioPattern;
            IdxAudioPattern = 0;
        }
        else
        {
            copysize = bytes;
            IdxAudioPattern_Next = bytes;
        }

        ALOGV("in loop IdxAudioPattern=%d, SizeAudioPattern=%d, copysize=%d, bytes=%d,", IdxAudioPattern, SizeAudioPattern, copysize, bytes);
    }
    IdxAudioPattern = IdxAudioPattern_Next;
}

void AudioFtm::FmTx_thread_digital_out(void)
{
    int SizeByte;

    SizeByte = mStreamOut->bufferSize();

    if (mDataBuffer == NULL)
    {
        mDataBuffer = new char[SizeByte];
    }

    IdxAudioPattern = 0;
    memset(mDataBuffer, 0, SizeByte);

    ALOGD("FmTx_thread_Digital_out: SizeByte=%d, mDataTable addr=%p", SizeByte, mDataTable);

    while (1)
    {
        if (!mAudioSinWave_thread)
        {
            ALOGD("exit FmTx_thread_Digital_out thread");
            break;
        }
        //Read pattern and write to audio stream output
        WavGen_AudioRead(mDataBuffer, SizeByte);
        mStreamOut->write(mDataBuffer, SizeByte);
    }

    if (mDataBuffer)
    {
        delete [] mDataBuffer;
        mDataBuffer = NULL;
    }

}

void AudioFtm::HDMI_thread_I2SOutput(void)
{
}

void *AudioFtm::FmTx_thread_create(void *arg)
{
    AudioFtm *p;
    p = (AudioFtm *)arg;

    ALOGD("FmTx_thread_digital_out");
    p->FmTx_thread_digital_out();
    pthread_exit(NULL);
    return NULL;
}

void *AudioFtm::HDMI_thread_create(void *arg)
{
    ALOGD("not supported!!!");
    return NULL;
}

bool AudioFtm::WavGen_SW_SineWave(bool Enable, unsigned int Freq, int type)
{
    return WavGen_SWPattern(Enable, Freq, type);
}

bool AudioFtm::WavGen_SWPattern(bool Enable, unsigned int Freq, int type)
{
    unsigned int Reg_Freq, Reg;
    ALOGD("WavGen_SW_SineWave, Enable=%d,  Freq = %d\n", Enable, Freq);

    if (Enable)
    {
        if (!mAudioSinWave_thread)
        {
            if ((Freq <= FREQ_NONE) || (Freq > FREQ_15K_HZ))
            {
                ALOGE("Invalid SineWave Frequency %d", Freq);
                return false;
            }
            else
            {
                switch (Freq)
                {
                    case FREQ_1K_HZ:
                        SizeAudioPattern = 192;
                        mDataTable = &stone1k_m4dB_48kHz[0];
                        break;
                    case FREQ_2K_HZ:
                        SizeAudioPattern = 96;
                        mDataTable = &stone2k_m4dB_48kHz[0];
                        break;
                    case FREQ_3K_HZ:
                        SizeAudioPattern = 64;
                        mDataTable = &stone3k_m4dB_48kHz[0];
                        break;
                    case FREQ_4K_HZ:
                        SizeAudioPattern = 48;
                        mDataTable = &stone4k_m4dB_48kHz[0];
                        break;
                    case FREQ_5K_HZ:
                        SizeAudioPattern = 192;
                        mDataTable = &stone5k_m4dB_48kHz[0];
                        break;
                    case FREQ_6K_HZ:
                        SizeAudioPattern = 32;
                        mDataTable = &stone6k_m4dB_48kHz[0];
                        break;
                    case FREQ_7K_HZ:
                        SizeAudioPattern = 192;
                        mDataTable = &stone7k_m4dB_48kHz[0];
                        break;
                    case FREQ_8K_HZ:
                        SizeAudioPattern = 24;
                        mDataTable = &stone8k_m4dB_48kHz[0];
                        break;
                    case FREQ_9K_HZ:
                        SizeAudioPattern = 64;
                        mDataTable = &stone9k_m4dB_48kHz[0];
                        break;
                    case FREQ_10K_HZ:
                        SizeAudioPattern = 96;
                        mDataTable = &stone10k_m4dB_48kHz[0];
                        break;
                    case FREQ_11K_HZ:
                        SizeAudioPattern = 192;
                        mDataTable = &stone11k_m4dB_48kHz[0];
                        break;
                    case FREQ_12K_HZ:
                        SizeAudioPattern = 64;
                        mDataTable = &stone12k_m4dB_48kHz[0];
                        break;
                    case FREQ_13K_HZ:
                        SizeAudioPattern = 192;
                        mDataTable = &stone13k_m4dB_48kHz[0];
                        break;
                    case FREQ_14K_HZ:
                        SizeAudioPattern = 96;
                        mDataTable = &stone14k_m4dB_48kHz[0];
                        break;
                    case FREQ_15K_HZ:
                        SizeAudioPattern = 64;
                        mDataTable = &stone15k_m4dB_48kHz[0];
                        break;
                    default:
                        SizeAudioPattern = 192;
                        mDataTable = &stone1k_m4dB_48kHz[0];
                        break;
                }
            }

            if (type == FTM_Audio_FMTx)
            {
                pthread_create(&m_WaveThread, NULL, AudioFtm::FmTx_thread_create, (void *)this);
            }
            else if (type == FTM_Audio_HDMI)
            {
                pthread_create(&m_WaveThread, NULL, AudioFtm::HDMI_thread_create, (void *)this);
            }
            else
            {
                ALOGD("WavGen_SWPattern fail");
            }

            mAudioSinWave_thread = true;
        }
        return true;
    }
    else
    {
        if (mAudioSinWave_thread)
        {
            //leave thread
            ALOGD("WavGen_SWPattern, destroy m_WaveThread");
            mAudioSinWave_thread = false;
            pthread_join(m_WaveThread, NULL);
        }
        return true;
    }
}


/// Output device test
int AudioFtm::RecieverTest(char receiver_test)
{
    ALOGD("%s(), receiver_test = %d", __FUNCTION__, receiver_test);

#if 0
    if (receiver_test) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_RECEIVER);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mLoopbackManager->SetLoopbackOff();
    }
#else
    if (receiver_test) // enable
    {
        mHardwareResourceManager->openAddaOutput(32000);
        mHardwareResourceManager->startOutputDevice(AUDIO_DEVICE_OUT_EARPIECE, 32000);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mHardwareResourceManager->stopOutputDevice();
        mHardwareResourceManager->closeAddaOutput();
    }
#endif
    return true;
}

int AudioFtm::LouderSPKTest(char left_channel, char right_channel)
{
    ALOGD("%s(), left_channel = %d, right_channel = %d", __FUNCTION__, left_channel, right_channel);
#if 0
    if (left_channel != false || right_channel != false) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_SPEAKER);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mLoopbackManager->SetLoopbackOff();
    }
#else
    if (left_channel != false || right_channel != false) // enable
    {
        mHardwareResourceManager->openAddaOutput(32000);
        mHardwareResourceManager->startOutputDevice(AUDIO_DEVICE_OUT_SPEAKER, 32000);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
        mHardwareResourceManager->setSgenSampleRate(SGEN_MODE_SAMPLERATE_32000HZ);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mHardwareResourceManager->stopOutputDevice();
        mHardwareResourceManager->closeAddaOutput();
    }
#endif
    return true;
}

int AudioFtm::EarphoneTest(char bEnable)
{
    ALOGD("%s(), bEnable = %d", __FUNCTION__, bEnable);
#if 0
    if (bEnable) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_EARPHONE);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mLoopbackManager->SetLoopbackOff();
    }
#else
    if (bEnable) // enable
    {
        mHardwareResourceManager->openAddaOutput(32000);
        mHardwareResourceManager->startOutputDevice(AUDIO_DEVICE_OUT_WIRED_HEADPHONE, 32000);
        mHardwareResourceManager->setSgenMode(SGEN_MODE_O03_O04);
    }
    else // disable
    {
        mHardwareResourceManager->setSgenMode(SGEN_MODE_DISABLE);
        mHardwareResourceManager->stopOutputDevice();
        mHardwareResourceManager->closeAddaOutput();
    }
#endif
    return true;
}

int AudioFtm::EarphoneTestLR(char bLR)
{
    // TODO
    return true;
}


/// Speaker over current test
int AudioFtm::Audio_READ_SPK_OC_STA(void)
{
    ALOGD("%s()", __FUNCTION__);
    struct mixer_ctl *ctl = NULL;
    int retval, dValue;

	ctl = mixer_get_ctl_by_name(mMixer, "Audio_Speaker_OC_Falg");


    if (NULL == ctl)
    {
        ALOGD("[%s] [%d]", __FUNCTION__, __LINE__);
        return true; //true means SPK OC fail
    }


    dValue = mixer_ctl_get_value(ctl, 0);

    ALOGD("-%s() value [0x%x]", __FUNCTION__, dValue);
    return dValue;
}

int AudioFtm::LouderSPKOCTest(char left_channel, char right_channel)
{
    ALOGD("%s()", __FUNCTION__);

    LouderSPKTest(left_channel, right_channel);

    return true;
}


/// Loopback
int AudioFtm::PhoneMic_Receiver_Loopback(char echoflag)
{
    ALOGD("%s(), echoflag = %d", __FUNCTION__, echoflag);

    if (echoflag == MIC1_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_RECEIVER);
    }
    else if (echoflag == MIC2_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_REF_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_RECEIVER);
    }
    else if (echoflag == MIC3_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_3RD_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_RECEIVER);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::PhoneMic_EarphoneLR_Loopback(char echoflag)
{
    ALOGD("%s(), echoflag = %d", __FUNCTION__, echoflag);

    if (echoflag == MIC1_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_EARPHONE);
    }
    else if (echoflag == MIC2_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_REF_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_EARPHONE);
    }
    else if (echoflag == MIC3_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_3RD_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_EARPHONE);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::PhoneMic_SpkLR_Loopback(char echoflag)
{
    ALOGD("%s(), echoflag = %d", __FUNCTION__, echoflag);

    if (echoflag == MIC1_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_MAIN_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_SPEAKER);
    }
    else if (echoflag == MIC2_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_REF_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_SPEAKER);
    }
    else if (echoflag == MIC3_ON) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_3RD_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_SPEAKER);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::HeadsetMic_EarphoneLR_Loopback(char bEnable, char bHeadsetMic)
{
    ALOGD("%s(), bEnable = %d", __FUNCTION__, bEnable);

    if (bEnable) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_HEADSET_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_EARPHONE);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::HeadsetMic_SpkLR_Loopback(char echoflag)
{
    ALOGD("%s(), enable = %d", __FUNCTION__, echoflag);

    static audio_mic_mask_t current_mic_device = AUDIO_MIC_MASK_NONE;

    if (echoflag) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_HEADSET_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_SPEAKER);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::HeadsetMic_Receiver_Loopback(char bEnable, char bHeadsetMic)
{
    ALOGD("%s(), enable = %d", __FUNCTION__, bEnable);

    static audio_mic_mask_t current_mic_device = AUDIO_MIC_MASK_NONE;

    if (bEnable) // enable
    {
        mLoopbackManager->SetLoopbackOn(AP_HEADSET_MIC_AFE_LOOPBACK, LOOPBACK_OUTPUT_RECEIVER);
    }
    else // disable
    {
        mLoopbackManager->SetLoopbackOff();
    }

    return true;
}

int AudioFtm::PhoneMic_Receiver_Acoustic_Loopback(int Acoustic_Type, int *Acoustic_Status_Flag, int bHeadset_Output)
{
    ALOGD("+%s(), Acoustic_Type = %d, headset_available = %d", __FUNCTION__, Acoustic_Type, bHeadset_Output);
    /*  Acoustic loopback
    *   0: Dual mic (w/o DMNR)acoustic loopback off
    *   1: Dual mic (w/o DMNR)acoustic loopback
    *   2: Dual mic (w/  DMNR)acoustic loopback off
    *   3: Dual mic (w/  DMNR)acoustic loopback
    */

    loopback_output_device_t loopback_output_device;
    if (bHeadset_Output == true)
    {
        loopback_output_device = LOOPBACK_OUTPUT_EARPHONE;
    }
    else
    {
        loopback_output_device = LOOPBACK_OUTPUT_RECEIVER; // default use receiver here
    }



    bool retval = true;
    static int acoustic_status = 0;
    switch (Acoustic_Type)
    {
        case ACOUSTIC_STATUS:
            *Acoustic_Status_Flag = acoustic_status;
            break;
        case DUAL_MIC_WITHOUT_DMNR_ACS_OFF:
            // close single mic acoustic loopback
            mLoopbackManager->SetLoopbackOff();
            acoustic_status = DUAL_MIC_WITHOUT_DMNR_ACS_OFF;
            break;
        case DUAL_MIC_WITHOUT_DMNR_ACS_ON:
            // open dual mic acoustic loopback (w/o DMNR)
            mLoopbackManager->SetLoopbackOn(MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITHOUT_DMNR, loopback_output_device);
            acoustic_status = DUAL_MIC_WITHOUT_DMNR_ACS_ON;
            break;
        case DUAL_MIC_WITH_DMNR_ACS_OFF:
            // close dual mic acoustic loopback
            mLoopbackManager->SetLoopbackOff();
            acoustic_status = DUAL_MIC_WITH_DMNR_ACS_OFF;
            break;
        case DUAL_MIC_WITH_DMNR_ACS_ON:
            // open dual mic acoustic loopback (w/ DMNR)
            mLoopbackManager->SetLoopbackOn(MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITH_DMNR, loopback_output_device);
            acoustic_status = DUAL_MIC_WITH_DMNR_ACS_ON;
            break;
        default:
            break;
    }

    ALOGD("-%s(), out -", __FUNCTION__);
    return retval;
}


/// FM / mATV
int AudioFtm::FMLoopbackTest(char bEnable)
{
    ALOGD("%s()", __FUNCTION__);
    return true;
}

int AudioFtm::Audio_FM_I2S_Play(char bEnable)
{
    ALOGD("%s()", __FUNCTION__);

    const float kMaxFmVolume = 1.0;

    if (mStreamOut == NULL)
    {
        if (mStreamManager->getStreamOutVectorSize() == 0) // Factory mode
        {
            uint32_t devices = 0x2;
            int format = 0x1;
            uint32_t channels = 0x3;
            uint32_t sampleRate = 44100;
            status_t status = 0;

            mStreamManager->openOutputStream(devices, &format, &channels, &sampleRate, &status);
        }

        mStreamOut = mStreamManager->getStreamOut(0);
    }

    if (bEnable == true)
    {
        // force assigned earphone
        AudioParameter paramRouting = AudioParameter();
        paramRouting.addInt(String8(AudioParameter::keyRouting), AUDIO_DEVICE_OUT_WIRED_HEADPHONE);
        mStreamOut->setParameters(paramRouting.toString());

        // enable
        mStreamManager->setFmVolume(0);
        mStreamManager->setFmEnable(true);
        mStreamManager->setFmVolume(kMaxFmVolume);
    }
    else
    {
        // disable
        mStreamManager->setFmVolume(0);
        mStreamManager->setFmEnable(false);
    }

    return true;
}

int AudioFtm::Audio_MATV_I2S_Play(int enable_flag)
{
    ALOGD("%s()", __FUNCTION__);
    return true;
}
int AudioFtm::Audio_FMTX_Play(bool Enable, unsigned int Freq)
{
    ALOGD("%s()", __FUNCTION__);

    if (Enable == true)
    {
        if (mStreamOut == NULL)
        {
            if (mStreamManager->getStreamOutVectorSize() == 0)
            {
                uint32_t devices = 0x2;
                int format = 0x1;
                uint32_t channels = 0x3;
                uint32_t sampleRate = 48000;
                status_t status = 0;

                mStreamManager->openOutputStream(devices, &format, &channels, &sampleRate, &status);
            }

            mStreamOut = mStreamManager->getStreamOut(0);
        }

        AudioParameter paramRouting = AudioParameter();
        paramRouting.addInt(String8(AudioParameter::keyRouting), AUDIO_DEVICE_OUT_FM);
        mStreamOut->setParameters(paramRouting.toString());

        WavGen_SW_SineWave(true, Freq, FTM_Audio_FMTx);
    }
    else
    {
        WavGen_SW_SineWave(false, Freq, FTM_Audio_FMTx);
        mStreamOut->standby();
        mStreamManager->closeOutputStream(mStreamOut);
        mStreamOut = NULL;
    }

    return true;
}

int AudioFtm::ATV_AudPlay_On(void)
{
    ALOGD("%s()", __FUNCTION__);
    return true;
}
int AudioFtm::ATV_AudPlay_Off(void)
{
    ALOGD("%s()", __FUNCTION__);
    return true;
}
unsigned int AudioFtm::ATV_AudioWrite(void *buffer, unsigned int bytes)
{
    ALOGD("%s()", __FUNCTION__);
    return true;
}


/// HDMI
int AudioFtm::HDMI_SineGenPlayback(bool Enable, int Freq)
{
    ALOGD("%s(), enable = %d Freq = %d", __FUNCTION__, Enable, Freq);

    if (Enable) // enable
    {
        mixer_ctl_set_enum_by_string(mixer_get_ctl_by_name(mMixer, "Audio_Hdmi_SideGen_Switch"), "On");
    }
    else // disable
    {
        mixer_ctl_set_enum_by_string(mixer_get_ctl_by_name(mMixer, "Audio_Hdmi_SideGen_Switch"), "Off");
    }
    return 0;
}


/// Vibration Speaker
int AudioFtm::SetVibSpkCalibrationParam(void *cali_param)
{
    ALOGD("%s()", __FUNCTION__);
    return SetAudioCompFltCustParamToNV(AUDIO_COMP_FLT_VIBSPK, (AUDIO_ACF_CUSTOM_PARAM_STRUCT *)cali_param);
}

uint32_t AudioFtm::GetVibSpkCalibrationStatus()
{
    ALOGD("%s()", __FUNCTION__);
    AUDIO_ACF_CUSTOM_PARAM_STRUCT audioParam;
    GetAudioCompFltCustParamFromNV(AUDIO_COMP_FLT_VIBSPK, &audioParam);
    if (audioParam.bes_loudness_WS_Gain_Max != VIBSPK_CALIBRATION_DONE && audioParam.bes_loudness_WS_Gain_Max != VIBSPK_SETDEFAULT_VALUE)
    {
        return 0;
    }
    else
    {
        return audioParam.bes_loudness_WS_Gain_Min;
    }
}

void AudioFtm::SetVibSpkEnable(bool enable, uint32_t freq)
{
    ALOGD("%s() enable:[%d] freq:[%d]", __FUNCTION__, enable, freq);
    if (enable)
    {
        AudioVIBSPKControl::getInstance()->setParameters(44100, freq, 0, 0);
    }
    AudioVIBSPKControl::getInstance()->setVibSpkEnable(enable);
}

void AudioFtm::SetVibSpkRampControl(uint8_t rampcontrol)
{
    ALOGD("%s()", __FUNCTION__);
    AudioVIBSPKControl::getInstance()->VibSpkRampControl(rampcontrol);
}

bool AudioFtm::ReadAuxadcData(int channel, int *value)
{
    struct mixer_ctl *ctl;
    int retval, dValue;
    channel = 0x001B; //AUX_SPK_THR_I_AP include mt_pmic.h
    ALOGD("+%s() channel [0x%x] (force to replace)", __FUNCTION__, channel);
    ctl = mixer_get_ctl_by_name(mMixer, "Audio AUXADC Data");
    if (NULL == ctl || NULL == value)
    {
        ALOGD("[%s] [%d]", __FUNCTION__, __LINE__);
        return false;
    }
    retval = mixer_ctl_set_value(ctl, 0, channel);
    usleep(1000);
    dValue = mixer_ctl_get_value(ctl, 0);
    *value = dValue;
    ALOGD("-%s() value [0x%x]", __FUNCTION__, dValue);
    return false;
}

status_t AudioFtm::setMicEnable(const audio_mic_mask_t audio_mic_mask, const bool enable)
{
    ALOGD("%s(), audio_mic_mask = 0x%x, enable = %d", __FUNCTION__, audio_mic_mask, enable);
    WARNING("Not implement!!");
    return NO_ERROR;
}


int AudioFtm::SetSpkMonitorParam(void *pParam)
{
    ALOGD("%s()", __FUNCTION__);
#if defined(MTK_SPEAKER_MONITOR_SUPPORT)
    return SetSpeakerMonitorParamToNVRam((AUDIO_SPEAKER_MONITOR_PARAM_STRUCT *)pParam);
#else
    return 0;
#endif
}

int AudioFtm::GetSpkMonitorParam(void *pParam)
{
    ALOGD("%s()", __FUNCTION__);
#if defined(MTK_SPEAKER_MONITOR_SUPPORT)
    return GetSpeakerMonitorParamFromNVRam((AUDIO_SPEAKER_MONITOR_PARAM_STRUCT *)pParam);
#else
    return 0;
#endif
}
void AudioFtm::EnableSpeakerMonitorThread(bool enable)
{
    ALOGD("%s()", __FUNCTION__);
#if defined(MTK_SPEAKER_MONITOR_SUPPORT)
    AudioALSASpeakerMonitor::getInstance()->EnableSpeakerMonitorThread(enable);
#endif
    return ;
}

void AudioFtm::SetStreamOutPostProcessBypass(bool flag)
{
    ALOGD("%s() %d", __FUNCTION__, flag);
    mStreamManager->setBypassDLProcess(flag);
    return ;
}

}
